.\\" auto-generated by docbook2man-spec $Revision: 1.1 $
.TH "MCparseModalFormula" "3" "09 April 2009" "" ""
.SH NAME
MCparseModalFormula \- C function that parses a modal mu-calculus formula and saves it to an ATerm.
.SH SYNOPSIS
.nf
\fB#include "libmcparse.h"
.sp
ATermAppl MCparseModalFormula(FILE *\fIformStream\fB);
(_Bool \fIreduce\fB);
(int \fIacLevel\fB);
(int \fIvbLevel\fB);
(_Bool \fIsaveToMCRLFormat\fB);
\fR.fi
.SH "PRECONDITIONS"
.PP
The following preconditions have to be satisfied:
.TP 0.2i
\(bu
the ATerm library is initialised
.TP 0.2i
\(bu
\fIformStream\fR points to a stream from which can be read
.TP 0.2i
\(bu
0 <= \fIacLevel\fR <= 2
.TP 0.2i
\(bu
0 <= \fIvbLevel\fR <= 3
.TP 0.2i
\(bu
if \fIsaveToMCRLFormat\fR, an mCRL data specification is present in the mCRL library
.SH "DESCRIPTION"
.PP
Function \fBMCparseModalFormula\fR parses the modal formula in \fIformStream\fR and saves it to a value of type \fBATermAppl\fR. The structure of the modal formula is explained in mucalculus(7). The structure of the \fBATermAppl\fR value is explained in the next subsection.
.PP
During parsing the formula is checked for monotonicity and adherence to the variable convention. Also the occurrences of dangerous nestings of fixed point variables are checked. If the first two checks fail, an error generated. If the third check succeeds a warning is generated.
.PP
If \fIreduce\fR is true, all regular operations are replaced by equivalent non-regular operations.
.PP
Alpha conversion is applied based on the value of \fIacLevel\fR:
0 (none)no alpha conversion1 (scope)names of bound variables that are in each other's scope are different2 (full)all names of bound variables are different
The printing of intermediate messages on stdout (besides error messages) is controlled by the value of \fIvbLevel\fR:
0 (silent)no messages are printed1 (normal)warnings are printed2 (verbose)warnings and short status information is printed3 (debug)many messages are printed to make debugging possible
If \fIsaveToMCRLFormat\fR is true, the types of expressions occurring in the modal formula are checked and the formula is translated to the internal mCRL format, using the data specification that is present in the mCRL library. During this translation, a version of full alpha conversion is performed that is provided by the mCRL library. Therefore, it isn't necessary to provide the parameter \fIacLevel\fR with the value 2; however, you are advised to do so, because this generates more readable names.
.PP
If parsing succeeded and no errors are generated, the parsed \fBATermAppl\fR value is returned; otherwise NULL is returned and an appropriate error message is printed on stderr.
.SS "STRUCTURE OF THE RESULT"
.PP
We describe the syntax and partly the semantics of the resulting ATerm of function \fBMCparseModalFormula\fR. In the following BNF syntax lowercase words are ATerm function symbols, expressions f(e0,...,en) are ATerm function applications of arity n, and expressions [e0,...,en] are ATerm lists of length n. Therefore, these terms have type \fBAFun\fR, \fBATermAppl\fR and \fBATermList\fR, respectively.
.PP
Preliminaries:
.sp
.nf
  AN       ::=  RNAME(DT,...,DT)
  VO       ::=  RNAME(DT,...,DT)
  DT       ::=  NAME(DT,...,DT)
  DT_LIST  ::=  [DT,...,DT]
  VD       ::=  v(RNAME,RNAME)
  VD_LIST  ::=  [VD,...,VD]
.sp
.fi
.PP
Here NAME and RNAME both denote mCRL names, AN represents action names, VO variable occurrences, DT data terms, DT_LIST lists of data terms, VD variable declarations and VD_LIST lists of variable declarations. Action and data names have to be declared, the data terms should be well typed and the right part of a variable declaration should be a declared sort. An RNAME is restricted such that the keywords "T", "F", "forall", "exists", "nil", "mu" and "nu" are not allowed. To be able to distinguish function symbols of the mu-calculus from mCRL function symbols, NAME and RNAME are quoted ATerms of type \fBATermAppl\fR.
.PP
Action formulas:
.sp
.nf
    AF  ::=  act(AN)  |  T  |  F  |  not(AF)
          |  and(AF,AF)  |  or(AF,AF)  |  imp(AF,AF)  |  eq(AF,AF)
          |  forall(NAME,NAME,AF)  |  exists(NAME,NAME,AF)
.sp
.fi
.PP
Here the symbol 'act' indicates that its parameter is an action name. The symbol 'T' stands for true, 'F' for false, 'not' for negation, 'and' for conjunction, 'or' for disjunction, 'imp' for implication, 'eq' for equivalence, 'forall' for universal quantification and 'exists' for existential quantification.
.PP
Regular formulas:
.sp
.nf
    RF  ::=  AF  |  nil  |  concat(RF,RF)  |  choice(RF,RF)
          |  tr_close(RF)  |  t_close(RF)
.sp
.fi
.PP
A regular formula denotes a path of action formulas. Here 'nil' stands for the empty path, 'concat' for the concatentation of two paths, 'choice' for the choice between two paths, 'tr_close' for the transitive and reflexive closure of a path and 't_close' for the transitive closure of a path.
.PP
Modal formulas:
.sp
.nf
    MF  ::=  form(DT)  |  T  |  F  |  not(MF)
          |  and(MF,MF)  |  or(MF,MF)  |  imp(MF,MF)  |  eq(MF,MF)
          |  forall(NAME,NAME,MF)  |  exists(NAME,NAME,MF) 
          |  may(RF,MF)  |  must(RF,MF)  |  loop(RF)  |  rec(VO)  
          |  mu(NAME, VD_LIST, MF, DT_LIST)  |  nu(NAME, VD_LIST, MF, DT_LIST)
.sp
.fi
.PP
Here the symbol 'form' indicates that its parameter is a boolean data term. The symbols 'T', 'F', 'not', 'and', 'or', 'imp', 'eq', 'forall' and 'exists' are analogous to the corresponding symbols in action formulas. The symbol 'may' stands for the may operator, 'must' for the must operator and 'loop' for the infinite looping operator. The symbol 'mu' stands for the smallest fixed point operator, 'nu' for the largest fixed point operator and 'rec' for the occurrence of a fixed point variable.
.PP
The may and must operators and the infinite looping operator have the following meaning. In a state of the state space a formula may(R,phi) is valid if there exists a path starting in this state, that satisfies R and leads to a state such that phi is valid. In a state of the state space a formula must(R,phi) is valid if all paths starting in this state, satisfying R, lead to a state such that phi is valid. In a state of the state space loop(R) holds if there exists a path starting in this state that is an infinite concatenation of sequences that satisfy R.
.PP
The generated formula adheres to the variable convention and it is monotonic, which means that every occurrence of a fixed point variable may only be in the scope of an even number of 'not' operations.
.SS "REDUCTION"
.PP
We call the operations 'nil', 'concat', 'choice', 'tr_close', 't_close' and 'loop' regular operations. When parameter \fIreduce\fR of function \fBMCparseModalFormula\fR has value true, then each regular operation in the modal formula is replaced by an equivalent non-regular operation. This is achieved by repeatedly applying the following properties from left to right, where X is fresh variable, i.e. X may not occur free in phi or R:
.sp
.nf
    may(nil,phi)            = may(tr_close(F),phi)
    may(concat(R1,R2),phi)  = may(R1,may(R2,phi))
    may(choice(R1,R2),phi)  = or(may(R1,phi),may(R2,phi))
    may(tr_close(R),phi)    = mu(X,[],or(phi,may(R,X),[])
    may(t_close(R),phi)     = may(concat(R,tr_close(R)),phi)
    
    must(nil,phi)           = must(tr_close(F),phi)
    must(concat(R1,R2),phi) = must(R1,must(R2,phi))
    must(choice(R1,R2),phi) = and(must(R1,phi),must(R2,phi))
    must(tr_close(R),phi)   = nu(X,[],and(phi,must(R,X),[])
    must(t_close(R),phi)    = must(concat(R,tr_close(R)),phi)
    
    loop(R)                 = nu(X,[],may(R,X),[])
.sp
.fi
.SH "KNOWN PROBLEMS"
.PP
The type \fB_Bool\fR is used instead of bool to avoid conflicts with reserved words in the mCRL library. This type is defined in the header file mcfunc.h.
.PP
If \fIsaveToMCRLFormat\fR is true, the types of actions are not checked because actions are not present in the internal mCRL format.
.SH "AUTHOR"
.PP
Written by Aad Mathijssen <A.H.J.Mathijssen@tue.nl>. Please send all complaints, comments and bug fixes to me.
.SH "SEE ALSO"
.PP
More information on the mu-calculus can be found in mucalculus(7). More information on the ATerm library can be found at the website of the CWI <URL:http://www.cwi.nl/htbin/sen1/twiki/bin/view/SEN1/ATermLibrary>.
