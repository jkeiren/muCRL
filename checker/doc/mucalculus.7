.\\" auto-generated by docbook2man-spec $Revision: 1.1 $
.TH "MUCALCULUS" "7" "09 April 2009" "" ""
.SH NAME
mucalculus \- syntax and semantics for the first-order modal mu-calculus extended with data-depended processes and regular formulas.
.SH "DESCRIPTION"
.PP
We describe the syntax and partly the semantics of the contents of extended mu-calculus formula files. Such a file has to contain exactly one modal formula, which itself consists of modal formulas, regular formulas and action formulas.
.SS "PRELIMINARIES"
.PP
In formula files, text starting with the symbol "%" until the end of the line character is considered to be comment. Further we need the following elements to describe action formulas, regular formulas and modal formulas:
.sp
.nf
    AN        ::=  RNAME | RNAME "(" DT_LIST ")"
    FORM      ::=  RNAME | RNAME "(" DT_LIST ")"
    DT        ::=  NAME  | NAME "(" DT_LIST ")"
    DT_LIST   ::=  DT    | DT_LIST "," DT
    VD        ::=  RNAME ":" RNAME
    VDI       ::=  VD "=" DT
    VDI_LIST  ::=  VDI   | VDI_LIST "," VDI
    FP_VD     ::=  RNAME | RNAME "(" VDI_LIST ")"
    FP_VO     ::=  RNAME | RNAME "(" DT_LIST ")"
.sp
.fi
.PP
Here NAME and RNAME both denote mCRL names, AN represents mCRL action names, FORM represents mCRL formulas, DT mCRL data terms, DT_LIST lists of data terms, VD mCRL variable declarations, VDI variable declarations with initialisations, VDI_LIST lists of variable declarations with initialisations, FP_VD fixed point variable declarations and FP_VO fixed point variable occurrences. In order to avoid ambiguity and to increase readability in action names, formulas, variable declarations and fixed point variables, an RNAME is restricted such that the mu-calculus keywords "T", "F", "forall", "exists", "nil", "mu" and "nu" are not allowed. Also names occurring in actions, formulas and data terms have to be declared and well-typed, formulas should be of type "Bool" and the right part of a variable declaration should be a declared sort. Finally every occurrence of a fixed point variable should be in the scope of a corresponding declaration, i.e. the declaration and the occurrence should have the same name and the same number of parameters, where each parameter is of the same type.
.SS "ACTION FORMULAS"
.PP
Action formulas are denoted by the non-terminal AF that has the following definition:
.sp
.nf
    AF  ::=  AN  |  "(" AF ")"  |  "T"  |  "F"  |  "!" AF  
          |  AF "&&" AF  |  AF "||" AF  |  AF "=>" AF  |  AF "==" AF  
          |  "forall" VD "." AF  |  "exists" VD "." AF
.sp
.fi
.PP
Here the symbol "T" stands for true, "F" for false, "!" for not, "&&" for and, "||" for or, "=>" for implication and "==" for equivalence. The rules starting with "forall" and "exists" stand for universal and existential quantification. The binary infix operators are left-associative except for "=>", which is right-associative. The quantifications and "!" have the highest priority, followed by "&&" and "||", followed by "=>", followed by "==". These priorities can be overruled with the use of parentheses.
.SS "REGULAR FORMULAS"
.PP
Regular formulas are denoted by the non-terminal RF that has the following definition:
.sp
.nf
    RF  ::=  AF  |  "(" RF ")"  |  "nil"  |  RF "." RF  |  RF "|" RF
          |  RF "*"  |  RF "+"
.sp
.fi
.PP
Here "nil" stands for empty, "." for concatenation, "|" for choice, "*" for the transitive and reflexive closure, and "+" for the transitive closure. The binary infix operators are left-associative. The unary operators have the highest priority, followed by ".", followed by "|". These priorities can be overruled with the use of parentheses.
.SS "MODAL FORMULAS"
.PP
Modal formulas are denoted by the non-terminal MF that has the following definition:
.sp
.nf
    MF  ::=  FORM  |  "(" MF ")"  |  "T"  |  "F"  |  "!" MF
          |  MF "&&" MF  |  MF "||" MF  |  MF "=>" MF  |  MF "==" MF 
          |  "forall" VD "." MF  |  "exists" VD "." MF 
          |  "<" RF ">" MF  |  "[" RF "]" MF  |  "@" "(" RF ")"
          |  "mu" FP_VD "." MF  |  "nu" FP_VD "." MF  |  FP_VO
.sp
.fi
.PP
The symbol "T" stands for true, "F" for false, "!" for not, "&&" for and, "||" for or, "=>" for implication and "==" for equivalence. The rules starting with "forall" and "exists" stand for universal and existential quantification, the rules "<" RF ">" MF and "[" RF "]" MF for the may and must operators, the rule "@" "(" RF ">" for the infinite looping operator and the rules starting with "mu" and "nu" for the smallest and largest fixed point operators. Recall that FORM represents an mCRL formula, VD an mCRL variable declaration, FP_VD the declaration of a fixed point variable and FP_VO the occurrence of a fixed point variable. The binary infix operators are left-associative except for "=>", which is right-associative. The quantifications, the prefix operators and the may and must operators have the highest priority, followed by "&&" and "||", followed by "=>", followed by "==". These priorities can be overruled with the use of parentheses.
.PP
The may and must operators and the infinite looping operator have the following meaning. In a state of the state space a formula <R>phi is valid if there exists a path starting in this state, that satisfies R and leads to a state such that phi is valid. In a state of the state space a formula [R]phi is valid if all paths starting in this state, satisfying R, lead to a state such that phi is valid. In a state of the state space @(R) holds if there exists a path starting in this state that is an infinite concatenation of sequences that satisfy R.
.SS "REMARKS"
.PP
For quantification variables, we have the following variable conventions:
.IP 1. 
each occurrence of a variable is bound by the nearest quantification in scope of which the bound variable has the same name and the same number of arguments
.IP 2. 
variables that are introduced by a fixed point quantification may not conflict, i.e. all names of non-fixed point variables have to be distinct
.PP
The first variable convention implies that is possible to analyse a modal formula without having a data type specification. The second variable convention prevents for meaningless formulas.
.PP
Formulas containing fixed point operators should be monotonic. Because "!" is not monotonic, every occurrence of a fixed point variable may only be in the scope of an even number of "!" operations.
.SH "RELATIONS BETWEEN SYMBOLS"
.PP
Besides the well-known relations between symbols of first-order logic, the following relations hold for regular formulas, for fresh variable X, i.e. X may not occur free in phi or R:
.sp
.nf
    <nil>phi   = <F*>phi
    <R1.R2>phi = <R1><R2>phi
    <R1|R2>phi = <R1>phi || <R2>phi
    <R*>phi    = mu X.(phi || <R>X)
    <R+>phi    = <R.R*>phi
    
    [nil]phi   = [F*]phi
    [R1.R2]phi = [R1][R2]phi
    [R1|R2]phi = [R1]phi && [R2]phi
    [R*]phi    = nu X.(phi && [R]X)
    [R+]phi    = [R.R*]phi
.sp
.fi
.PP
The following relations hold for the modal operators, where phi(!X) represents substitution of !X for every free occurrence of X in phi:
.sp
.nf
    [R]phi     = !<R>!phi
    nu X.phi   = !mu X.!phi(!X)
.sp
.fi
.PP
For infinite looping we have, for fresh X:
.sp
.nf
    @(R)       = nu X.<R>X
.sp
.fi
.SH "EXAMPLES"
.PP
Freedom of deadlock:
.sp
.nf
    [T*]<T>T
.sp
.fi
.PP
There exists a loop a.b.c:
.sp
.nf
    <T*>@(a.b.c)
.sp
.fi
.PP
Action b may not happen after an action c, unless an action a occurs after this c and before this b:
.sp
.nf
    [(!c)*.c.((!a && !b)* | a.(!c)*.c)*.b]F
.sp
.fi
.PP
The same formula but now b may not occur initially:
.sp
.nf
    [((!a && !b)* | a.(!c)*.c)*.b]F
.sp
.fi
.PP
These formulas are equivalent to the following formulas in which no regular operations, i.e. empty path "nil", concatenation ".", choice "|", transitive reflexive closure "*", transitive closure "+" and looping "@", occur:
.sp
.nf
    nu X.(<T>T && [T]X)
    mu X.(nu Y.(<a><b><c>Y) || <T>X)
    nu X.([c] nu Y.([b]F && (nu Z.(Y && [!a && !b]Z) &&
      [a] nu Z.([c]Y && [!c]Z))) && [!c]X)
    nu X.([b]F && (nu Y.(X && [!a && !b]Y) && [a] nu Y.([c]X && [!c]Y)))
.sp
.fi
.SH "AUTHOR"
.PP
Written by Aad Mathijssen <A.H.J.Mathijssen@tue.nl>. Please send all complaints, comments and bug fixes to me.
.SH "SEE ALSO"
.PP
The C function \fBMCparseModalFormula\fR from the library \fBlibmcparse\fR parses a mu-calculus formula and saves it to an ATerm. More information on this function can be found in MCparseModalFormula(3). More information on the ATerm library can be found at the website of the CWI <URL:http://www.cwi.nl/htbin/sen1/twiki/bin/view/SEN1/ATermLibrary>.
